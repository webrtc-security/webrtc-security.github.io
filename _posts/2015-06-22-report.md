---
layout: post
title: A Study of WebRTC Security
---

## Abstract

Web Real-Time Communication (abbreviated as WebRTC) is a recent trend in web application technology, which promises the ability to enable realtime communication in the browser without the need for plug-ins or other requirements.
However, the open-source nature of the technology may have the potential to cause security-related concerns to potential adopters of the technology.
This paper will discuss in detail the security of WebRTC, with the aim of demonstrating the comparative security of the technology.

## 1. Introduction

WebRTC is an open-source web-based application technology, which allows users to send real-time media without the need for installing plugins. Using a suitable browser can enable a user to call another party simply by browsing to the relevant webpage.

Some of the main use cases of this technology include the following:

- Real-time audio and/or video calls
- Web conferencing
- Direct data transfers

Unlike most real-time systems (e.g. SIP), WebRTC communications are directly controlled by some Web server, via a JavaScript API.

The prospect of enabling embedded audio and visual communication in a browser without plugins is exciting. However this naturally raises concerns over the security of such technology, and whether it can be trusted to provide reliable communication for both the end users and any intermediary carriers or third parties.

This report will address these topics and examine the protections that WebRTC provides to provide security in all cases. For the purposes of this paper however, native applications will be treated as being out of scope.

## 2. Overview of WebRTC Architecture

WebRTC enables direct media-rich communication between two peers, using a peer-to-peer (P2P) topology. WebRTC resides within the user's browser, and requires no additional software to operate. The actual communication between peers is prefaced by an exchange of metadata, termed "signalling". This process is used to initiate and advertise calls, and facilitates connection establishment between unfamiliar parties.

As depicted in Figure 1, this process occurs through an intermediary server:

                    +----------------+
                    |                |
                    |    Signaling   |
                    |    Server      |
                    |                |
                    +----------------+
                      ^           ^
                     /             \
         Signaling  /               \   Signaling
                   /                 \
                  /                   \
                 v                     v
               JS API                  JS API
          +-----------+             +-----------+
          |           |    Media    |           |
          |  Browser  |<----------->|  Browser  |
          |           |             |           |
          +-----------+             +-----------+
              Alice                      Bob

Figure 1. A simple WebRTC Call Topology

A signaling protocol is not specified within WebRTC, allowing developers to implement their own choice of protocol. This allows for a deeper degree of flexibility in adapting a WebRTC app for a specific usecase or scenario.

### How does WebRTC communication work?

WebRTC relies on three APIs, each of which performs a specific function in order to enable real-time communication within a web application. These APIs will be named and explained briefly. The implementation and technical details of each protocol and technology are outside the scope of this report, however the relevant documentation is readily available online.

#### getUserMedia

For many years it was necessary to rely on third-party browser plugins such as Flash or Silverlight to capture audio or video from a computer. However, the era of HTML 5 has ushered in direct hardware access to numerous devices, and provides JavaScript APIs which interface with a system's underlying hardware capabilities.

getUserMedia is one such API, enabling a browser to access a user's camera and microphone. Although utilised by WebRTC, this API is actually offered as part of HTML 5.

#### RTCPeerConnection

https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection

RTCPeerConnection is the first of two APIs which are offered specifically as part of the WebRTC specification. A RTCPeerConnection interface represents the actual WebRTC connection, and is relied upon to handle the efficient streaming of data between two peers.

When a caller wants to initiate a connection with a remote party, the browser starts by instantiating a RTCPeerConnection object. This includes a self-generated SDP (INSERT HYPERLINK) description to exchange with their peer. The recipient in turn responds with it's own SDP description. The SDP descriptions are used as part of the full ICE workflow (INSERT HYPERLINK) for NAT traversal.

With the connection now established, RTCPeerConnection enables the sending of real-time audio and video data as a bitstream between browsers.

Ultimately, RTCPeerConnection API is responsible for managing the full life-cycle of each peer-to-peer connection and encapsulates all the connection setup, management, and state within a single easy-to-use interface.

RTCPeerConnection has two specific traits:
 - Direct peer-to-Peer communication between two browsers
 - Use of UDP/IP - there is no guarantee of packet arrival (as in TCP/IP), but there is much reduced overhead as a result.
  - (By allowing the loss of some data, we can focus upon offering real-time communication.)

#### RTCDataChannel

The RTCDataChannel is the second main API offered as part of WebRTC, and represents the main communication channel through which the exchange of arbitrary application data occurs between peers. In other words, it is used to transfer data directly from one peer to another.

Although a number of alternative options for communication channels exist (e.g. WebScoket, Server Sent Events), however these alternatives were designed for communication with a server rather than a directly-connected peer. RTCDataChannel resembles the popular WebSocket, but instead takes a peer-to-peer format while offering customisable delivery properties of the underlying transport.

## 2.1. Underlying Technologies

The three main APIs are the developer-facing aspects of WebRTC, but there are a number of foundational technologies which are utilised in order to provide these protocols (the RTCPeerConnection and RTCDataChannel APIs).

![Figure X. WebRTC Protocol Stack](http://orm-chimera-prod.s3.amazonaws.com/1230000000545/images/hpbn_1803.png)

ICE, STUN, and TURN (INSERT HYPERLINKS) are necessary to establish and maintain a peer-to-peer connection over UDP. DTLS (INSERT HYPERLINK) is used to secure all data transfers between peers, as encryption is a mandatory feature of WebRTC. Finally, SCTP and SRTP (INSERT HYPERLINK) are the application protocols used to multiplex the different streams, provide congestion and flow control, and provide partially reliable delivery and other additional services on top of UDP.

### SDP: Session Description Protocol

http://tools.ietf.org/id/draft-nandakumar-rtcweb-sdp-01.html

Session Description Protocol (SDP) is a descriptive protocol that is used as a standard method of announcing and managing session invitations, as well as performing other initiation tasks for multimedia sessions. SDP represents the browser capabilities and preferences in a text-based format, and may include the following information:
- Media capabilities (video, audio) and the employed codecs
- IP address and port number
- P2P data transmission protocol (WebRTC uses SecureRTP)
- Bandwidth usable for communication
- Session attributes (name, identifier, time active, etc.) -> However these are not used in WebRTC.
- Other related metadata...

As of today SDP is widely used in the contexts of Session Initiation Protocol (SIP), Real-time Transport Protocol (RTP), and Real-time Streaming Protocol (RSP).

### ICE: Interactive Connectivity Establishment

http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/#after-signaling-using-ice-to-cope-with-nats-and-firewalls

Signalling requires the use of an intermediary server for the exchange of metadata, but upon completion WebRTC attempts to establish a direct P2P conneciton between users. This process is carried out through the ICE framework.

ICE is a framework used for establishing a connection between peers over the internet. Although WebRTC tries to utilise direct P2P connection, in reality the widespread presence of NAT (Network Address Translation) makes it difficult to negotiate how two peers will communicate.

Due the continuing widespread prevailence of IPv4 addresses being limited by their 32-bit representation, most network-enabled devices do not have a unique public-facing IPv4 address with which it would be visible on the Internet. Network Address Translators (NAT) work by changing a private address into a public one when an outbound request passes through them.

ICE attempts to overcome the difficulties posed by communicating via NAT to find the best path to connect peers.

It tries all possibilities in parallel and chooses the most efficient option that works. ICE first tries to make a connection using the host address obtained from a device's operating system and network card; if that fails (which it will for devices behind NATs) ICE obtains an external address using a STUN server, and if that fails, traffic is routed via a TURN relay server.

The candidate communication routes are rendered in a text-based format, which take the form of one of the following:
- direct P2P communication
- Using STUN, with a port mapping for NAT traversal  (This route eventually resolves to P2P communication)
- Using TURN as an intermediary; (this configuration employs relayed communication rather than P2P).

Out of the candidates, the routes with the smallest overhead are chosen. The list is ordered by priority.

### STUN: Session Traversal Utilities for NAT

In order to perform P2P communication, both parties necessarily require at least the knowledge of their peer's IP address and the assigned UDP port. As a result, a certain amount of information exchange is necessary before WebRTC communication can be established.

A STUN server is used by each peer to determine their public IP address, and is referenced by the ICE framework during connection establishment.


### TURN: Traversal Using Relays around NAT

In the eventuality that establishing a P2P communication fails, a fallback can be provided via a TURN server. By relaying traffic between peers the WebRTC communication can still be established, but can suffer degregations in media quality and latency.

TURN servers can ensure high success in setting up calls, regardless of the end-user's environments. As the data is sent through an intermediary server, server bandwidth is also consumed. If many calls are simulataneously routed through the server, the bandwidth was also become considerable in size.

As, the server itself has to be provided (or rented) by the application provider.







## 3. Browser-based Security Considerations

From http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-security :

There are a number of ways in that a real-time communication application may impose security risks, both on the carrier and the end users. Such security risks can be applicable to any application which deals with the transmission of real-time data and media. WebRTC differs from other RTC apps by providing a strong and reliable infrastructure for even new developers to utilise without compromising on security. We will now proceed to discuss how WebRTC deals with each of these risks in turn.

### Browser Trust Model

The WebRTC architecture assumes from a security perspective that network resources exist in a hierarchy of trust. From the user's perspective, the browser (or user client) is basis of all WebRTC security, and acts as their Trusted Computing Base (TCB).

The browser's job is to enable access to the internet, while providing adequate security protections to the user. The security requirements of WebRTC are built directly upon this requirement.

The browser is the portal through which the user accesses all WebRTC applications and content.

While HTML and JS provided by the server can cause the browser to execute a variety of actions, the browser segregates those scripts into sandboxes. Said sandbox isolates scripts from each other, and from the user's computer. Generally speaking, scripts are only allowed to interact with resources from the same domain - or more specifically, the same "origin".

The browser enforces all security policies that the user desires and is the first step in the verification of all third parties. All authenticated entities have their identity checked by the browser.

If the user chooses a suitable browser which they know can trust, then all WebRTC communication can be considered "secure" and to follow the standard accepted security architecture of WebRTC technology. However, if there is any doubt that a browser is "trustable" (e.g. having been downloaded from a third party rather than a trusted location), then all following interaction with WebRTC applications is impacted and may not be reliably secure.

I.e, The level of trust provided to the user by WebRTC is directly influenced by the user's trust in the browser.

### Same Origin Policy

    Check: Third parties cannot offer a WebRTC app on their site, right? Or can they?

    https://tools.ietf.org/html/draft-ietf-rtcweb-security-05#section-3.2 <-- oudated! Be careful.
    https://tools.ietf.org/html/draft-ietf-rtcweb-security-08#section-3.2 <-- latest version

It is a fundamental aspect of the DOM that all webpage resources are fetched from the page's web server, whenever some or all of the page is loaded. Fetching of resources takes place either when a page is freshly loaded by the browser, or when a script residing on a webpage makes such a request. Such scripts are readily able to make HTTP requests via e.g. the XMLHttpRequest() API, but are not permitted to make such requests to any specified server. Requests have to be made to the same "Origin" from where the script originated. This restrication is termed the "Same Origin Policy" (SOP).

SOP forces scripts to execute in isolated sandboxes specific to their originating domain, therefore preventing pages from the different origins or even iframes on the same page from exchanging information. Webpages and scripts from the same origin server remain unhindered in interacting with each otherâ€™s JS variables. As such, the Origin constitutes the basic unit of web sandboxing.

Through enforcing execution sandboxes on a per-origin basis, the end user is protected from the misuse of their credentials. You would reasonably expect to safely use a social networking website without a script executing from within an advertisement panel and stealing your login information.

Similarly, the servers of e.g the webpage provider are protected attacks mounted via the user's browser; If such safeguards did not exist, DoS attacks could otherwise be launched through abusive resource requests.

#### Bypassing SOP:

SOP is incredibly important for the security of both the user and web servers in general, although it does have the disadvantage of making certain types of web app harder to create. Methods of permitting inter-site interaction do exist, although these are typically mutually consensual and limited to certain channels.

The W3C Cross-Origin Resource Sharing (CORS) spec is one of the answers to the problem. It allows the browser to contact the script's target server to determine whether it is willing to participate in the transaction. As such, cross-origin requests can be safely allowed, by giving the target server the option to decline any such requests.

WebSockets is another option allowing similar functionality, but on transparent channels rather than isolated HTTP requests. Once such a connection has been established, the script can transfer traffic and resources as it likes, with the necessity of framing as a series of HTTP request/response transactions.

In both cases, the initial verification stage prevents the arbitrary transfer of data to another origin.



## 4. WebRTC Security Considerations

### 4.1. Installation and Updates

A prevalent issue with traditional desktop software is that of trust of the application itself. Installation of new software or a plugin can also surruptiously install malware or other undesirable software. Many end users have no idea where the software was made or exactly who they are downloading the app from. Malicious third paties have additionally had great success in repackaging perfectly safe and trusted software to include malware, and offering their custom package on free software websites.

WebRTC however is not a plugin, nor is there any installation process for any of it's components. All the underlying WebRTC foundation is installed as simply part of downloading a suitable WebRTC-compatible browser, such as Chrome or Firefox. If a user has such a browser, they can browse to and use any WebRTC application with no other setup or preparation required. As such there is no risk of installation of malware or viruses through the use of an appropriate WebRTC application.

Further to the above, WebRTC components run in a sandbox within the browser and not in a separate process. (**Expand on this**)

Another related consideration is the patching of discovered security flaws in software. As with any software technology, it is entirely possible that future bugs or vulnerabilities will be discovered in WebRTC. If a vulnerability is found in an traditional desktop application (for example: a typical VoIP application), development of a patch may take considerable time. This is a frequent issue with application development, as security is still often treated as a secondary consideration after functionality. Going further, contemplate hardware-based communication methods. How often does a VoIP phone get a security update? Do you trust the person responsible to update it regularly? Do you know who is responsible?

Contrary to this, browsers are a fast-paced development scene due to the frequency and range of risks users are exposed to, as well as their ubiquitous nature (and the importance of information accessed through the browser). As WebRTC's components are offered as part of a browser, they are likewise updated whenever the browser is updated. If a future vulnerability were to be found in a browser's WebRTC implementation, a fix will likely be delivered rapdily. (Note: Chrome and Firefox's rapid development cycles). In fact, in the era of automatic (background) updates WebRTC components can be updated through a new browser version as soon as the patch is made available on servers. Most browsers today like Google Chrome and Mozilla Firefox have a goof record of auto-updating themselves within 24 hours of a vulnerability of threat occurring .

As a side note: Although we have stated that WebRTC requires no plugins to be installed, it is possible that third-party WebRTC frameworks may offer plugins to enable support on currently unsupported browsers (such as Safari and IE). User caution (or a supported browser) is recommended in such instances.

### 4.2. Access to Media/Local resources

The browser can access local resources (including camera, mic, files), which leads the inevitable concern of a web application accessing a user's microphone and camera. If web applications could freely gain access to a user's camera or microphone, an unscrupulous app may record or distribute video or audio feeds without the user's knowledge. It could be a simple matter for a website residing in a background tab to abuse the user's trust (the user may not even realise a site harbours such a communication application).

WebRTC combats this by requiring the user to give explicit permission for the camera or microphone to be used (both can be configured indivudally). It is possible to ask the user for one-time or permanent access. It is not possible for a WebRTC application to arbitrarily gain access or operate. Furthermore, when either the microphone or camera is being used the client UI is required to expressly show the user that the microphone or camera are being operated. (In Chrome, this takes the form of a red dot on any tab accessing a user's media.)

These mechanisms enforce that the user has control over which applications are permitted access to their media, and that they are visually reminded that such activity is occurring. Even if the user were to forget they had permitted an app to broadcast from their media devices, [the browser UI] will remind them such that they can disable the app before accidentally broadcasting unintended behaviour or information.

![Figure X. Chrome UI Indicators](http://i.imgur.com/a1XfIR2.png)
![Figure X. Chrome UI Indicators](http://cdn.slashgear.com/wp-content/uploads/2014/01/chrome_32.jpg)

The philosophy of this security protection is that a user should always be making an informed decision on whether they should permit a call to take place, or to receive a call. I.e. a user must understand:
- Who or what is requesting access to his media
- Where the media is going
- Or both.

As an additional provision, the WebRTC spec specifies that browsers SHOULD stop the camera and microphone when the UI indicator is masked (e.g. by window overlap). (Which browsers offer this?)
- Although this is more ideal behaviour, it isn't necessarily guarenteed and users should exercise caution. Fortunately however, this is not likely to be behaviour expected by the user (better than expected protection?).

Screen sharing introduces further security considerations due to the inherent flexibility of scope. A user may not be immediately aware of the extent of the information that they are sharing. For instance, they may believe they are simply sharing a stream of a particular window (e.g. while giving a presentation to remote parties), when in reality they are showing their entire screen to their audience.
- This may be a result of the user failing to correctly establish the initial setup, or else that the user may simply forget the extent of what they are sharing.

**Access to Media/Local resources (Part 2)**

- Web servers are strictly limited or forbidden from accessing local files, camera and microphone.

- Possible to produce an HTML form which will allows file upload...
    - But a script cannot do it without user consent
    - And cannot specify a particular file! (e.g. /etc/passwd)
        - User explicitly selects file and agrees to uploading

        - Browsers are often explicitly designed to avoid dialogs with the semantics of "click here to screw yourself!"



Similarly, we cannot allow web servers to arbitrarily initiate calls or otherwise access a user's microphone or webcam.
If no access restrictions were enforced, a site could spy upon a user without prior given user consent.


### 4.3. Media Encryption & Communication Security

There are a number of ways in that a real-time communication application may impose security risks. One particularly notable one is the interception of unencrypted media or data during transmission. This can occur between browser-browser or browser-server communication, with an eavesdropping third-party able to see all data sent. Encryption however, renders it effectively impossible for an eavesdropper to determine the contents of communication streams. Only parties with access to the secret key can decode the communication streams.

Encryption is a mandatory feature of WebRTC, and is enforced on all components, including signaling mechanisms. Resultantly, all media streams sent over WebRTC are securely encrypted, enacted through standardised and well-known encryption protocols. The encryption protocol used depends on the channel type; data streams are encrypted using Datagram Transport Layer Security (DTLS) and media streams are encrypted using Secure Real-time Transport Protocol (SRTP).

#### 4.3.1. DTLS: Datagram Transport Layer Security

http://blog.cryptographyengineering.com/2012/01/attack-of-week-datagram-tls.html

WebRTC encrypts information (specifically data channels) using Datagram Transport Layer Security (DTLS). All data sent over RTCDataChannel is secured using DTLS.

DTLS is a standardised protocol which is built into all browsers that support WebRTC, and is consistently used in web browsers, email, and VoIP platforms to encrypt information. This also means that no prior setup is required. As with other encryption protocols it is designed to prevent eavesdropping and information tampering. DTLS itself is modelled upon the stream-orientated TLS, a protocol which offers full encryption with asymmetric cryptography methods, data authentication, and message authentication. TLS is the de-facto standard for web encryption, utilised for the purposes of HTTPS etc etc. TCP is designed for the reliable transport mechanism of TCP, but VoIP apps (and games etc) utilise unreliable datagram transports such as UDP.

DTLS is a derivative of SSL, meaning all data will be as secure as using any standard SSL based connection. In fact, WebRTC data can be secured via any standard SSL based connection on the web, allowing WebRTC to offer end-to-end encryption between peers with almost any server arrangement.

##### 4.3.1.1. DTLS over TURN?

P2P encryption is easy to envisage and setup, but allow us to contemplate TURN briefly.
A TURN server's purpose is the relay of WebRTC data between parties in a call, and will only parse the UDP layer of a WebRTC packet. Servers will not decode the application data layer  in order to route it, and therefore they cannot understand or modify information that peers send each others.

The protections put in place through encryption are therefore not compromised during WebRTC communication over TURN.

~~Same for media & data. Can build a secure file-sharing application in the browser using RTCDataChannel.~~

#### 4.3.2. SRTP: Secure Real-time Transport Protocol

RTP does not have any built-in security mechanisms, and thus places no protections of the confidentiality of transmitted data. External mechanisms are relied on to provide encryption. In fact, the use of unencrypted RTP is explicitly forbidden by the WebRTC specification.

WebRTC utilises SRTP for the encryption of mediastreams, rather than DTLS. (This is likely because SRTP is lighter-weight than DTLS. Incorporate Iwase-san's comment here.) The specification requires any compliant WebRTC implementation support RTP/SAVPF (which is built on top of RTP/SAVP) [link: http://tools.ietf.org/wg/rtcweb/]. The actual SRTP key exchange is performed end-to-end with DTLS-SRTP.
    - Ensures that any MITM attack can be detected (Incorporate Iwase-san's comment here.) (https://support.silentcircle.com/customer/portal/articles/1644771-what-about-dtls-srtp-why-not-use-that-)

#### 4.3.3. Establishment of a secure link

http://www.onsip.com/webrtc-sip-network/webrtc-implementation/webrtc-security

Let us step through the process of establishing a new call on a WebRTC application. In this instance, there will be two parties involved; Alice and Bob. The call procedure is initiated when one party (Alice) calls the other (Bob), and the signalling process exchanges the revelant metadata between both parties.

Once the initial ICE checks have concluded (or specifically, some of them), the two peers will start to setup one or more secure channels. Initially, a DTLS handshake is performed on all channels that are established by ICE. For the data channels, this step alone is sufficient as plain simple DTLS is used for encryption. For the media channels however, further steos are taken.

Once the DTLS handshake completes, the keys are "exported" and used to key SRTP for the media channels. At this stage both parties know that they share a set of secure data and/or media channels with keys which are not known to any malicious third-party.

####  4.3.4. DTLS-SRTP vs SDES

https://webrtchacks.com/webrtc-must-implement-dtls-srtp-but-must-not-implement-sdes/

In order to negotiate the security parameters for the media traffic session, SRTP needs to interact with a key management protocol. This protocol is not established, offering up a number of possible options for the task, such as SDES, and DTLS-SRTP.

It is worth noting that the signalling (SIP, HTTP) & media (RTP) involved in a multimedia communication can be (are?) secured independently.

**SDES**

SDP Security Descriptions for Media Streams (SDES) was the option previously favoured by WebRTC (check this).

Within SDES, the security parameters and keys used to set up SRTP sessions are exchanged in clear text in the form of SDP attributes. As SDP is communicated over the signalling place, if encryption is not additionally enacted upon such signalling messages then an eavesdropping third party could obtain the keys for the SDES encrypted data. In other words, a further encrpytion protocol should be utilised specifically for the encryption of the signalling plane. One such option for this is to use TLS.

Securing the signalling and media independently however, can lead to the situation in that the media user is different from the signalling user (no guarentee is provided). To provide this guarentee, a cryptographic binding is necessary. DTLS-SRTP is one such mechanism that provides this, but SDES does not.

It remains a fact that even today, the majority of RTP traffic in VoIP networks is not secured. In fact, encyption is one of the very first features customers usually ask vendors to remove in order to meet their budgets. When secured, most of the deployments utilise SDES, which as we just mentioned relies heavily on signalling plane security.

*To Check:* The Encryption key is apparently embedded in header? (Anybody could read the key)

**DTLS-SRTP**

DTLS-SRTP on the other hand exchanges keys over the media plane, rather than the signalling plane. The consequence of such a difference is that an SRTP media channel has no need to reveal the secret encryption keys through an SDP message exchange, as is the case with SDES.

The WebRTC specification (http://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-07) asserts that WebRTC implementations are required to support DTLS-SRTP for key management. Moreover, it is to be the default and preferred scheme, and there is no provision for other key management schemes to be implemented. In other words, other schemes may or may not be supported at all.

If an "offer" (elaborate!) is received advertising support for both DTLS-SRTP and SDES, DTLS-SRTP must be selected - irrespective of whether the signalling is secured or not (what?? check!).

**The Debate**

(http://tools.ietf.org/wg/rtcweb/agenda?item=agenda-87-rtcweb.html)

It is generally accepted that DTLS-SRTP should be the madatory and default option for the encryption of WebRTC media. What is being questioned is whether other mechanisms, namely SDES, should be utilised to provide backward compatability.

From the compatibility persepctive, Google's Chrome browser provides support for both SDES and DTLS-SRTP. Mozilla's Firefox on the other hand only implementes DTLS-SRTP.





#### Attacks on DTLS

http://www.isg.rhul.ac.uk/~kp/dtls.pdf
- Heartbleed

#### A Weakness in SRTP!

SRTP only encrypts the payload of RTP packets, providing no encryption for the header. However, the header contains a variety of information which may be desirable to keep secret.

One such piece of information included in the RTP header is the audio-levels of the contained media data. Effectively, anyone anyone who can see the SRTP packets can tell whether a user is speaking or not at any given time. Although the contents of the media itself remains secret to any eavesdropper, this is still a scary prospect.
- Law enforcement officals could determine whether a user is communicating with a known badguy etc etc.
- How about muted video.

### 4.4. Web-Based Peer Authentication / Identity Management

(This section goes beyond simply authenticating through a signalling service. Make sure I write about this!)

It is desirable for a user to be able to verify the identify of their peers. I.e. a user naturally wants to be certain that they are speaking to the person they believe that they are speaking to, and not an imposter.

Although the signalling server may be able to go some way towards claiming a user's identity (can it? - It seems it can vouch for them, but it might not necessarily be trsutworthy), the signalling server itself may not (and for the case of authentication SHOULD not) be trusted. We need to be able to perform authentication of our peers independently from the Signalling Server. This can be made possible through the use of identity providers.


                               +----------------+
                               |                |
                               |    Signaling   |
                               |     Server     |
                               |                |
                               +----------------+
                                   ^        ^
                                  /          \
                          HTTPS  /            \   HTTPS
                                /              \
                               /                \
                              v                  v
                           JS API              JS API
                     +-----------+            +-----------+
                     |           |    Media   |           |
               Alice |  Browser  |<---------->|  Browser  | Bob
                     |           | (DTLS+SRTP)|           |
                     +-----------+            +-----------+
                           ^      ^--+     +--^     ^
                           |         |     |        |
                           v         |     |        v
                     +-----------+   |     |  +-----------+
                     |           |<--------+  |           |
                     |   IdP1    |   |        |    IdP2   |
                     |           |   +------->|           |
                     +-----------+            +-----------+

                 Figure X: A call with IdP-based identity

A number of web-based identity providers (IdP) have recently become commonplace on the web, including Facebook Connect, BrowserID (by Mozilla), OAuth (by Twitter). The purpose of these mechanisms is simply to verify your identity to other services/users, on the authority of the identity provider itself. If a user has an account on Facebook then they can then use Facebook Connect, Facebook's IdP to prove to others that the are who they say they are on Facebook. This allows users to tie their authentication on other services to their main account on a "trusted" service. Note that in this case the level of "trust" that an Identity Provider possesses is subjective to the end-point user or service, and is often largely tied to userbase and reputation across the World Wide Web.

The implementations of each IdP differs due to independent development by different companies rather than being based on an open-source standard (? verify this.), but the underlying principle and functionality remains essentially the same. IdPs do not provide authentication for a signalling server; rather, they provide authentication for a user (and their browser through the process). WebRTC also places no requirements on which services should be used, and those which are utilised are based on the web application's implementation.

As the web application (calling site) is unrelated to this authentication process, it is important that the browser securely generates the input to the authentication process, and also securely displays the output on the web application. This process must not be able to be falisified or misrepresented by the web application.

                +--------------------------------------+
                | Browser                              |
                |                                      |
                | +----------------------------------+ |
                | | https://calling-site.example.com | |
                | |                                  | |
                | |        Calling JS Code           | |
                | |               ^                  | |
                | +---------------|------------------+ |
                |                 | API Calls          |
                |                 v                    |
                |          PeerConnection              |
                |                 ^                    |
                |                 | API Calls          |
                |     +-----------|-------------+      |   +---------------+
                |     |           v             |      |   |               |
                |     |       IdP Proxy         |<-------->|   Identity    |
                |     |                         |      |   |   Provider    |
                |     | https://idp.example.org |      |   |               |
                |     +-------------------------+      |   +---------------+
                |                                      |
                +--------------------------------------+

                Figure X: The operation of an Identity Provider






### 4.5. IP Location Privacy

One adverse side-affect of using ICE is that a peer can learn one's IP address. As IP addresses are publicly registered with global authorities, they can reveal such details as a given peer's location. This could naturally have negative implications for a peer, which they would wish to avoid.


~~WebRTC is not designed with the intention of protecting a user from a malicious website which wants to learn this information.~~ (Clearly not true)
Typically, such a site will learn at least a user's server reflexive address from any HTTP transaction.
- hiding the IP address from the server requires some sort of explicit privacy preserving mechanism on the client (out of scope)

WebRTC does however provide a number of mechanisms which are intended to allow a web application to cooperate with the user to hide the user's IP address from the other side of the call. These mechanisms will be detailed in turn.

A WebRTC implementation is required to provide a mechanism to allow JS to suppress ICE negotiation until user has decided to answer the call. This provision assists end users in preventing a peer from learning their IP address if they elect not to answer a call. This has the side affect of hiding whether a user is online or not to their peers.

The second such provision is that any implementation will provide a mechanism for the calling app JS to indicate that only TURN candidates are to be used. This can prevent a peer from learning one's IP address at all.

    - MUST provide a mechanism for the calling app to reconfigure an existing call to add non-TURN candidates.
      - Taken together with the previous, allows ICE negotiation to start immediately on incoming call notification (reducing delay)
        - But avoiding disclosing the user's IP address until they have decided to answer
      - Also allows users to completely hide their IP address for the duration of the call.

REPHRASE THE FOLLOWING:

https://datatracker.ietf.org/doc/draft-ietf-rtcweb-security/?include_text=1  


## 4.6. Signalling Layer

http://www.onsip.com/webrtc-sip-network/webrtc-implementation/webrtc-security

As the signalling protocol is not specified by WebRTC, the mechanism for encryption obviously depends on the signalling protocol chosen. Due to the relatively open nature of signalling security, this report will focus on and briefly explain some of the most common protocols.

SIP: Session Initiation Protocol

STP is a widely implemented standard used in VoIP communication to setup and tear down phone calls.

http://searchunifiedcommunications.techtarget.com/feature/Security-in-a-SIP-network-Identifying-network-attacks

SIP is a derivative of HTTP and SMTP - both are protocols that are regularly exploited. As it uses plain-text messages to exchange infromation, it is feasbile for any malicious party to tap a network and capture SIP messages. If an attacker can read a user's sensitive information, they could use this information to spoof the user. If the attacker can further proceed to gain access to the operator's network, in the context of WebRTC, this would mean gain access into a call? (check).


Since SIP is sent in clear text, it is trivial for a determined attacker to intercept SIP messages. What happens next is left up to the imagination of the attacker, but it is not hard to imagine an eventually in that the contents of the message body or header is tampered with.
- If the attacker intercepts an INVITE message, they may then proceed to change the FROM header to reflect his or her own IP address.

### SIP Vulnerabilities

(The following is related to SIP and VoIP. Need to confirm it 100% corresponds to WebRTC too.)

http://www.symantec.com/connect/articles/two-attacks-against-voip

SIP is a communications protocol for signalling and controlling multimedia communication sessions. It is frequently implemented in VoIP applications for the purposes of setting up and tearing down phone calls.



It can be similarly used in a WebRTC implementation for signalling purposes, as one of a number of possible such options.

However, SIP messages are frequently sent in plain text. This naturally can result in a number of potential attack vectors. Let's have a look at these.

*SIP Flow*

In the process of setting up a call, a user's browser (or "User Agent") registers with a central registrar. This registration is a necessity in tradition VoIP as it is necessary to provide the means to locate and contact a remote party.

When a party (Bob) wants to initiate a call, he sends an INVITE message via a central proxy server (this is the signalling server). The server is responsible for relaying such messsages, and providing the means to locate the other users.

The server may attempt a number of measures to locate a end-user during this lookup process (e.g. DNS and the "routing of various SIP messages (provisional and informational)").

*Registration Hijacking*

The initial browser registration is used to announce a user's point of contact, and indicates that a user's device is accepting calls. However the process provides a vector for malicious entities to perform a "Registration Hijack" attack.

The exchange of registration messages includes a "Contact:" field, containing the user's IP address. Whenever the signalling server processes an incoming call, the user name (or phone number) is matched up with the registered IP address, and the INVITE is forwarded accordingly. These registrations last 60 seconds by default (check this!), ensuring information is up to date.

As SIP messages are always sent in plain text, it can be trivial for an attacker to intercept and read the contents of these registration messages. Following the interception, an appropriate tool (such as SiVuS Message generator) can be used to generate similar SIP information, but with the user's true IP address replaced by the attacker's own. The attacker then only has to disable the real user and send this information periodically to divert all incoming calls to themselves.

There are a number of methods that an attacker could utilise to disable a legitimate user, including:
    - Performing a DoS attack against the user's device
    - Deregistering the user (another attack which is not covered here)
    - Generating a registration race-condition in which the attacker sends repeatedly REGISTER requests in a shorter timeframe (such as every 15 seconds) in order to override the legitimate user's registration request.

As the implementation of SIP does not support the checking integrity of the message contents, modification and replay attacks are therefore not detected and are a feasible attack vector. This attack works even if the server requires authentication of user registration, as the attacker can once again capture, modify and replay messages as desired.

This attack can be suppressed by implementing SIPS (SIP over TLS) and authenticating SIP requests and responses (which can include integrity protection). In fact, the use of SIPS and the authentication of responses can suppress many associated attacks including eavesdropping and message or user impersonation.

*Other Stuff*

Being Edited. With incorporate elsewhere.

Attacker could instigate a MiTM attack by intercepting the initial SIP messages.
- Registration hijacking
    - Allows attacker to cut off calls that are about to come and conclude how those calls are routed.

- Replay attack
    - If packets are replayed to server, it may call someone


    Session hijacking
    - Used to take over a session in progress
    - web server is not stateful
        - each request is a separate session (alleviates need for continuously authenticating)
        - uses cookies for authentication
            - nothing more than a data file containing the session ID.
            - sent by the web server to the browser upon initial access
    - if cookie is intercepted and copied, it allows an interceptor full access to a session already in progress.
        - most sites generate cookies using an algorithm involving user IP address and a timestamp to create a unique identifier.

### VoIP attacks

As an upcoming VoIP technology, there is naturally the risk that WebRTC may inherit some traditional VoIP attacks. In this section we will examine such concerns.



Denial of Service attacks (DoS attacks) rely on the  delivery of massive quantities of messages (signalling traffic) in order to exhaust the CPU, memory or bandwidth if the target system or device.
- One objective can be to obtain login, password or extension number info.
- Attack can also be used to force a crash in a SIP proxy.


Traditional VoIp attacks normally involved network attackers.
- With WebRTC we also need to deal with web attackers. WebRTC services must be designed to protect against both.

**SIP Encryption**

But! All is not lost; In addition to the media streams, the signalling layer can also be encrypted. ~~SIP can be used with encryption.~~ One such example is OnSIP, which uses SIP over Secure WebSockets (wss:// instead of ws://). The WebSocket connection is encrypted by TLS.



Although outside of this report's scope, other signalling technologies can similarly use TLS to encrypt their WebSocket or other web traffic similarly.


- Authentication
- Additionally, the signalling layer can provide authentication and a
(finish this section)


## 4.???. RTC Security Considerations


**Security in RTC Apps**

#### Browser Security


Typical Concerns include:

- Cross-site scripting (XSS)
    - One of the typical vulnerabilities often found in web applications. XSS vulnerabilities allow attackers to inject client-side scripts into web pages to be viewed by others.
        - Can be used by attackers to bypass access controls e.g. same origin policy
    - As the primary method for accessing WebRTC is (presently) HTML5.



### Additional Security Topics


**Security over TURN**

The default option (if possible) for all WebRTC communication is direct P2P communication between two browsers (aided with signalling servers). However if P2P communication cannot be established between users, a fallback option is the possibility of having a WebRTC application communicate via a TURN server. During TURN communication the media can suffer a loss of quality and increased latency, but it allows an "if all else fails" scenario to permit WebRTC application to work even under challenging circumstances.

Due to the difference in the operational architecture of TURN-based communication in WebRTC and the regular WebRTC architecture, new security considerations should be discussed.

- WebRTC communication is encrypted end-to-end between peers
- The TURN server does not perform decryption/re-encryption of the packets
- The TURN server does not learn the secret key required for decrypting the transmitted media streams.

(I think)

**Areas of Security risk:**

- Improperly coded applications/Incorrectly implemented protocols
    - Are such applications at risk?
    - Not likely, no.

- Operating System bugs

- Social engineering and phishing attacks
    - Research this.



https://altanaitelecom.wordpress.com/2014/10/03/security-for-webrtc-applications/

Identity Management

(From viewpoint of telecom network)

- By providing support to WebRTC, a telecom network should not be exposed to increased security risk
- Devices or software in the hands of consumers will inevitably be compromised (?)

FOR THIS REASON:
    - All data received from untrusted sources (e.g. from consumer/users) must be validated
    - (ASSUME) Any data sent to the client will be obtained by malicious souces.

By adopting these two principles, a telecom provider must strive to make all reasonable attempts at protecting the consumer from their OWN mistakes (that may compromise their own systems)






## 5. Comparison with competing/similar technologies

This section will explore the comparitive strengths and weaknesses of WebRTC and other platforms offering competiting RTC functionality.

Some platforms we COULD explore are the following. The platforms to be explored have not yet been chosen. (To come after first-draft.)

Although widely relied upon, the additional installation processes can pose a barrier

- Flash
- Silverlight
- Jabber
- SIP
~~- ORTC (https://bloggeek.me/ortc-webrtc/)~~


## 6. Secure Coding Practices (Good (secure) coding conventions for WebRTC applications.)

WebRTC is built to be secure. However more than just bindly relying on the underlying technology, it is a good idea to code with security consciously in mind. This section will mention coding practices that can be followed to ensure greater security than a standard WebRTC implementation. In particular, these practices could be of benefit to organisations which expect to handle senstive information, eg. banking institutions, healthcare institutions or confidential corporate information.

*Secure Signalling*

As mentioned previously, WebRTC does not impose any constraints on the signalling process, rather leaving the developer to decide upon their own preferred methods. Although this allows for a degree of flexibility that can have the WebRTC implementation tailored to the needs of the application, there can be risks associated with certain signalling protocols. Others can provide additional security.

Applications with a focus upon security/confidentiality would ensure that their signalling layer is over a secure protocol such as SIP / HTTPS / WSS.

*Authentication and peer monitoring*

A basic WebRTC app requires only a user's ID in order to perform a call, with no authentication performed from the view point of the service itself. It may be desirable to require pre-registration or authentication before any user can participate in a call. Unauthenticated entities should then be kept away from sessionâ€™s reach, restricting accessibility to untrusted parties.

Since the media connections are P2P, the media contents like audio video channel are between peers directly in full duplex. Thus as the signalling server maintains the number of peers , it could be consistently monitored for addition of suspicious peers in a call session. If the number of peers actually present on signalling server is more that the number of peers interacting on WebRTC page then it means that someone is eavesdropping secretly and should be terminated from session access by force.

*Permission Requests*

It is a noted behaviour that often users will agree to permission requests or similar dialogs without consciously reading the message. As this poses the risk of providing a web application with permissions which were not actually intended by the user.

Although this behaviour itself can not be easily dealt with, one solution could be to clearly detail on the page what permissions the application will ask for. Such an application places a user's privacy at the forefront.

*Man-In-The-Middle*

Monitor the media path regularly for no suspicious relay.


*Screen Sharing*

An application offering any degree of screen-sharing functionality should have warnings in place to protect the user. As previously discussed, a user may not be aware of the extent of the screen being shared. Such an issue should fall back to a properly designed application to provide appropriate such information.

For example, before initiating the streaming of any part of the screen, the user should be properly notified and advised to close any screen containing sensitive information.

*A Fallback*

As a final fallback measure, we could venture as far as imagining a situation in that an active call session is compromised by a unauthorised party. If a call is confirmed to be compromised in such a way, it should be within the power of Web Application server rendering the WebRTC capable page to cut off the call.

**Encryption for Signalling**

As stated previously, the signalling process is outside of the WebRTC specification. As such the developer is free to implement their desired solution, which allows flexibility to match the needs of the web application (as well as competition).

However, by default a signalling process may not incorporate any encryption, which can leave the contents of all exchanged signalling messages open to eavesdropping. As this is obviously hugely undesirable, developers are recommended to choose an appropriately secure protocol for their own WebRTC application.

Once such example is OpenSIP.

### 6.1. Case Studies

*To be discussed with team*

Part of above topic?

Idea:

- Make multi-party conference app
    - With weaknesses?
    - Explain how to resolve weaknesses.


## 7. Conclusion

"With WebRTC, Security isnâ€™t just ingrained in the implementation, but it is built in a way that pushes developers to take it seriously." https://bloggeek.me/webrtc-most-secure-voip/

WebRTC is the most secure VoIP solution out there, and leads the field by adopting the right security concepts


Main premise of having encryption by default is that a call is private at all times. Security and encryption are no longer considered to be optional features.
-> Big advantage over most VoIP services. Most security is typically optional, meaning most people use VoIP calls without encryption


It is not feasible to send unencrypted media using a WebRTC application. The WebRTC specification forbids the transmission of media streams over unencrypted RTP. (Specifically, it is forbidden that implementations negotiate cipher suits with NULL encryption modes.) (See: https://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-11#section-5.5)

This ensures users are protected from unwanted intrusions into their private communication, and maintains information integrity by disallowing information tampering on data channels. With appropriate encryption, it is infeasible for a malicious third party to eavesdrop on the encrypted contents. The (correct) secret key is necessary to decrypt the ciphertext. Without the key, the third party will only be able to see seemingly random (meaningless) data.


## 8. Bibliography

To Do.


### Links to check:

https://tools.ietf.org/html/draft-ietf-rtcweb-security-05

https://altanaitelecom.wordpress.com/2014/10/03/security-for-webrtc-applications/ *** <- Look at this tomorrow!
https://altanaitelecom.wordpress.com/2015/04/24/webrtc-security/

http://www.visionmobile.com/blog/2012/09/webrtc-a-new-game-changer-disrupting-telcos-and-otts/
https://www.pkcsecurity.com/blog

http://chimera.labs.oreilly.com/books/1230000000545/ch18.html#_brief_introduction_to_rtcpeerconnection_api


### To do:

**Encryption:**
- DH algorithm
- WebRTC previously used SDES
    - Encryption key is embedded in header
    - Anybody could read the key

**Look at SIP book**

http://www.kapejod.org/en/2014/05/security-implications-of-webrtc-part-2-end-to-end-encryption-well-no/
-> Use for "Coding best-practices!"
-> Also - STUN gun?

**Redraw diagrams etc**

### WebRTC-specific areas of interest: (Checklist)

- Identity Management âœ”ï¸Ž
- Browser Security
- Authentication
- Media encryption âœ”ï¸Ž


### Other Stuff

Information that doesn't yet have a place, or was moved. For future consideration.

WebRTC's powerful APIs allow developers to develop real-time communications applications in the browser without the need for any downloads or plugins to run.
- The proliferation of media streaming applications also presents new considerations within the realm of security.
- WebRTC bypasses this by offering developers end-to-end encryption by default in their applications
    - Developers can easily reassure their users


*Can I use WebRTC to open a UDP connection?*

No. There are too many security issues allowing WebRTC to send to a random address/port - we have to make sure it doesn't work as a DDOS platform, so we require the target to implement ICE as an implicit permission to send data, and we also don't allow sending arbitrary data, just SRTP mediastreams and data in DataChannels (over SCTP over DTLS over UDP+ICE).


*Encryption*

WebRTC employs mandatory encryption for both media and data.

- Secure pathways
    - Signaling is secured by using HTTPS
    - Media/Data communications are encrypted using different technologies:
      - Audio/Video data is sent other SRTP
      - Data is sent over DTLS

Encrypted Communications is undoubtably the most important security aspect for WebRTC. Due to the security guarentees offered by this protection, any connected peers know that their communications are both

"security guarentees provided by..." <- let's use this somewhere else! Sounds good.

Additional coding practice:

2. Make sure that ICE values are masked thereby not rendering the caller/ calleeâ€™s IP and location to each other through tracing in chrome://webrtc-internals/ or packet detection in Wirehsark on userâ€™s end.
